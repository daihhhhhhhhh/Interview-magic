# RPC框架面试总结-RPC原理及实现

一、什么是RPC

 RPC是远程调用过程的简写，是一个协议，处于网络通信协议的第五层：会话层，其下就是TCP/IP协议，在建立在其基础上的通信会话协议。RPC定义了交互的模式，而应用程序使用这些模式，来访问其他服务器的方法，并不需要关系具体的网络上的细节。     

        RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。

比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决。

    RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）
    
    RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）
    
    RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。

二、RPC框架实现原理

        在RPC框架中主要有三个角色：Provider、Consumer和Registry。如下图所示：

![](https://img-blog.csdnimg.cn/20190511091751847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FmYzg5MzA4NTg=,size_16,color_FFFFFF,t_70)

节点角色说明：

    * Server: 暴露服务的服务提供方。
    
    * Client: 调用远程服务的服务消费方。
    
    * Registry: 服务注册与发现的注册中心。

三、RPC调用流程

            RPC基本流程图：

![](https://img-blog.csdn.net/20160330210322989)

从RPC的角度看，应该有服务的提供方，即生产者；还有服务的调用方，即消费者。

     对消费者来时，在RPC调用过程中，使用第1步、第2步、第3步、第4步是透明的，其他的都是使用RPC框架去封装这些事情。当应用开始调用PRC的方式时，就会去容器中去取Bean对象，所以我们应该首先注册Bean对象到容器中，我们通过Java的动态代理，将代理过程封装到代理对象中，代理对象实现接口，创建实例到容器中。相应的，在调用远程对象的对象方法时，就会调用动态代理中的方法，这就是代理层的作用。
    
     代理对象在获取到请求方法、接口和参数时，就会用序列化层，将这些信息封装成一个请求报文，再让通信层向服务端传送报文的内容，然后就到了生产者这块。
    
     相应的服务必须有个监听器，来监听来自其他服务的请求，一般都会用容器做消息的监听，就会调用对应的Bean对象的方法，去处理响应的请求。当然，RPC框架不会让容器中的每一个框架都会被调用，所以只有注册了的Bean才会被RPC的请求调用到。然后，通过请求中的类、方法、参数，反射调用对应的Bean，拿到结果之后，通过序列化层，封装好结果报文，服务端的通信层将报文反馈给调用方，调用方解析到返回值，动态代理类返回结果，调用结束。
    
     这样，一个完整的RPC调用反馈链条就完成了。


    1.消费者设计

![](https://img-blog.csdn.net/20160330212347122)

①代理层： 消费者将对应的接口，通过RPC框架的代理来生成一个对象到Spring容器中。代理层将代理接口生成该接口的对象，该对象处理调用时传过来的对象、方法、参数，通过序列化层封装好，调用网络层。

②序列化层： 将请求的参数序列化成报文；将返回的报文反序列化成对象；

③网络层： 将报文与服务端通信；接收返回结果。

 

  2.生产者设计

![](https://img-blog.csdn.net/20160330213844175)


 ①代理层：  一个应用提供服务，必须由一个网络监听的模块，这个模块大多有开源的容器来处理网络上的监听；服务需要注册，只有注册了的服务才可以被调用；注册的服务需要被我们发射调用到，来进行相应的处理。

 ②序列化层：  就是相应的做请求的反序列化和结果的序列化。

 ③网络层： 接收客户端报文；将序列化的结果返回给客户端。

 

   3、RPC模式总结

 ![](https://img-blog.csdn.net/20160330214747335)

    1.Proxy代理层
    
     用于对象的代理；对象的反射调用；RPC流程的控制。
    
     2.Serialize序列化层
    
     将请求序列化和结果反序列化。
    
     3.Invoke网络模块
    
     主要用于网络通信的相关处理。
    
     4.Container容器组件
    
     这层主要用于代理层监听网络请求。

四、服务注册&发现

 ![](https://img-blog.csdnimg.cn/20190511091941773.png)

服务提供者启动后主动向注册中心注册机器ip、port以及提供的服务列表；

   服务消费者启动时向注册中心获取服务提供方地址列表，可实现软负载均衡和Failover；

五、使用到的技术

1、动态代理

        生成 client stub和server stub需要用到 Java 动态代理技术 ，我们可以使用JDK原生的动态代理机制，可以使用一些开源字节码工具框架 如：CgLib、Javassist等。

2、序列化

        为了能在网络上传输和接收 Java对象，我们需要对它进行 序列化和反序列化操作。

* 序列化：将Java对象转换成byte[]的过程，也就是编码的过程；

* 反序列化：将byte[]转换成Java对象的过程；

        可以使用Java原生的序列化机制，但是效率非常低，推荐使用一些开源的、成熟的序列化技术，例如：protobuf、Thrift、hessian、Kryo、Msgpack
        
            关于序列化工具性能比较可以参考：jvm-serializers

3、NIO

        当前很多RPC框架都直接基于netty这一IO通信框架，比如阿里巴巴的HSF、dubbo，Hadoop Avro，推荐使用Netty 作为底层通信框架。

4、服务注册中心

    可选技术：
    
        * Redis
    
        * Zookeeper
    
        * Consul
    
        * Etcd
