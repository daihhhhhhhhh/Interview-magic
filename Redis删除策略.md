# Redis删除策略

Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能

set key的时候，都可以给一个expire time，就是过期时间，通过过期时间就可以指定这个key可以存活的时间

 

过期数据：Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态

XX：具有时效性的数据   -1：永久有效的数据   -2：已经过期的数据或被删除的数据或未定义的数据

 

时效数据的存储结构

![img](https://img2020.cnblogs.com/blog/1928247/202004/1928247-20200411180840910-1899644307.png)

 数据删除策略的目标：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄漏

数据删除策略：定时删除+定期删除+惰性删除

　　定时删除：创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作

　　　　　　　优点：节约内存，到时就删除，快速释放掉不必要的内存占用

　　　　　　　缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量

　　　　　　　总结：用处理器性能换空间

　　定期删除：redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢?假如redis存了几十万个key，每隔100ms就遍历所有的设置过期时间的key的话，就会给CPU带来很大的负载。

　　　　　expires[i] i代表库　　

　　　　　Redis启动服务器初始化时，读取配置server.hz的值，默认为10

　　　　　每秒钟执行server.hz次serverCron()-->databasesCron()-->activeExpireCycle()

　　　　　activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250ms/server.hz　

　　　　　对某个expires[*]检测时，随机挑选W个key检测：如果key超时，删除key；如果一轮中删除的key的数量>W*25%，循环该过程；如果一轮中删除的key的数量<=W*25%，检查下一个expires[*]，0-15循环（默认值设置为16的话）

　　　　　W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值

　　　　　参数curret_db用于记录activeExpireCycle()进入哪个expires[*]执行

　　　　　如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行

　　　　　

　　　　周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度

　　　　特点1：CPU性能占用设置有峰值，检测频度可自定义设置

　　　　特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理

　　　　总结：周期性抽查存储空间

 

　　惰性删除：定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个key，才会被redis给删除掉。这就是所谓的惰性删除。expireIfNeeded(),检查数据是否过期，执行get的时候调用

　　　　　　优点：节约CPU性能，发现必须删除的时候才删除

　　　　　　缺点：内存压力很大，出现长期占用内存的数据

　　　　　　总结：用存储空间换取处理器性能（随机抽查，重点抽查）

 ![img](https://img2020.cnblogs.com/blog/1928247/202004/1928247-20200411183116606-864558802.png)

 

 

 

 

逐出算法

新数据进入检测：当新数据进入redis时，如果内存不足怎么办？

Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。

注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。

（err）OOM command not allowed when used memory > 'maxmemory'

 

最大可使用内存maxmemory：占用物理内存的比例，默认值为0，表示不限制。通常设置在50%以上

每次选取待删除数据的个数：maxmemory-samples 选取数据时并不会全库扫描，导致严重的性能损耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据

删除策略：maxmemory-policy 达到最大内存后，对被选出来的数据进行删除的策略

 

redis内存淘汰机制  redis提供6种数据淘汰策略：

 

配置：maxmemory-policy volatile-lru

 

检测易失性数据（可能会过期的数据集server.db[i].expires）

volatile-lru --> 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

volatile-lfu-->从已设置过期时间的数据集中挑选最不经常使用的数据淘汰

volatile-ttl-->从已设置过期时间的数据集中挑选将要过期的数据淘汰

volatile-random -->从已设置过期时间的数据集中任意选择数据淘汰

 

检测全库数据（所有数据集server.db[i].dict）

allkeys-lru --> 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（最常用）

allkeys-random-->从数据集中任意选择数据淘汰

allkeys-lfu-->当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

 

放弃数据驱逐

no-eviction-->禁止驱逐数据（redis4.0默认策略），也就是说当内存不足以容纳新写入数据时，新写入操作或报错，回引发OOM（Out of memory）

 

可以通过info命令查看缓存命中次数