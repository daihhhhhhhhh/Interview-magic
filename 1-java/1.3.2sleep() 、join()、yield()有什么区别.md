# 1.3.2sleep()、join()、yield()有什么区别

## 线程状态

1. NEW 新建状态，线程创建且没有执行start方法时的状态
2. RUNNABLE 可运行状态，线程已经启动，但是等待相应的资源（比如IO或者时间片切换）才能开始执行
3. BLOCKED 阻塞状态，当遇到synchronized或者lock且没有取得相应的锁，就会进入这个状态
4. WAITING 等待状态，当调用`Object.wait`或者`Thread.join()`且没有设置时间，在或者`LockSupport.park`时，都会进入等待状态。
5. TIMED_WAITING 计时等待，当调用`Thread.sleep()`或者`Object.wait(xx)`或者`Thread.join(xx)`或者`LockSupport.parkNanos`或者`LockSupport.partUntil`时，进入该状态
6. TERMINATED 终止状态，线程中断或者运行结束的状态



## Wait(), Notify() , NotifyAll()的使用

1. 调用wait\notify\notifyall方法时，需要与锁或者synchronized搭配使用，不然会报错`java.lang.IllegalMonitorStateException`，因为任何时刻，对象的控制权只能一个线程持有，因此调用wait等方法的时候，必须确保对其的控制权。
2. 如果对简单的对象调用wait等方法，如果对他们进行赋值也会报错，因为赋值相当于修改的原有的对象，因此如果有修改需求可以外面包装一层。
3. notify可以唤醒一个在该对象上等待的线程，notifyAll可以唤醒所有等待的线程。
4. wait(xxx) 可以挂起线程，并释放对象的资源，等计时结束后自动恢复；wait()则必须要其他线程调用notify或者notifyAll才能唤醒。

## 1、sleep()方法

sleep()方法需要制定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同等级或者高优先级的线程得到执行的机会，也可以让低优先级的线程的到执行的机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享的数据。

## 2、wait()

wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，他们都是Object类的方法，而不是Thread类的方法。

wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志“。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的所有权。当调用了某个对象的notifyAll()方法，会使对象等待池中的所有线程都异动到该对象的锁标志等待池。

除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程池将恢复到锁标志等待池。

此外，wait()，notify()，notifyAll()只能在synchronized语句中使用， 但是如果使用的是ReenTranLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTranLock.newCondition()获取一个Condition类对象，然后Condition的wait()，Signal()以及SignalAll()分别对应上面的三个方法。

## 3、yield()

yield()方法和sleep方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行的状态，所以执行yield()的线程有可能进入到可执行状态后又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。

## 4、join()

join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行。

wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前运行的线程。虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！ 

这样理解: 例子中的Thread t只是一个对象 , isAlive()判断当前对象(例子中的t对象)是否存活, wait()阻塞的是当前执行的线程(例子中的main方法)

可以看出，Join方法实现是通过wait()。 当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁),调用该对象的wait()，直到该对象唤醒main线程 ，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。

```csharp
void join():当前线程等该加入该线程后面，等待该线程终止。
void join(long millis):当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度。
void join(long millis,int nanos):等待该线程终止的时间最长为 millis 毫秒 + nanos纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度。
```

