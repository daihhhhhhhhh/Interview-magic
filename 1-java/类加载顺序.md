# 类加载顺序

```
什么时候类加载 
第一次需要使用类信息时加载。 
类加载的原则：延迟加载，能不加载就不加载。 

触发类加载的几种情况： 
(1)、调用静态成员时，会加载静态成员真正所在的类及其父类。 通过子类调用父类的静态成员时，只会加载父类而不会加载子类。 
(2)、第一次 new 对象的时候 加载(第二次再 new 同一个类时，不需再加载)。 
(3)、加载子类会先加载父类。（覆盖父类方法时所抛出的异常不能超过父类定义的范围） 
    注：如果静态属性有 final 修饰时，则不会加载，当成常量使用。 
    例：public static final int a =123; 但是如果上面的等式右值改成表达式(且该表达式在编译时不能确定其值)时则会加载类。 
    例：public static final int a = math.PI 如果访问的是类的公开静态常量，那么如果编译器在编译的时候能确定这个常量的值，就不会被加载； 
如果编译时不能确定其值的话，则运行时加载 
```

------

```
 
类加载的顺序： 
1.加载静态成员/代码块： 
    先递归地加载父类的静态成员/代码块(Object的最先)；再依次加载到本类的静态成员。 
    同一个类里的静态成员/代码块，按写代码的顺序加载。 
    如果其间调用静态方法，则调用时会先运行静态方法，再继续加载。同一个类里调用静态方法时，可以不理会写代码的顺序。 
    调用父类的静态成员，可以像调用自己的一样；但调用其子类的静态成员，必须使用“子类名.成员名”来调用。 
2.加载非静态成员/代码块：（实例块在创建对象时才会被加载。而静态成员在不创建对象时可以加载） 
    先递归地加载父类的非静态成员/代码块(Object的最先)；再依次加载到本类的非静态成员。 
    同一个类里的非静态成员/代码块，按写代码的顺序加载。同一个类里调用方法时，可以不理会写代码的顺序。 
    但调用属性时，必须注意加载顺序。一般编译不通过，如果能在加载前调用，值为默认初始值(如：null 或者 0)。 
    调用父类的非静态成员(private 除外)，也可以像调用自己的一样。 
3.调用构造方法：
    先递归地调用父类的构造方法(Object的最先)也就是上溯下行；默认调用父类空参的，也可在第一行写明调用父类某个带参的。 
    再依次到本类的构造方法；构造方法内，也可在第一行写明调用某个本类其它的构造方法。 
    注意：如果加载时遇到 override 的成员，可看作是所需创建的类型赋值给当前类型。 
    其调用按多态用法：只有非静态方法有多态；而静态方法、静态属性、非静态属性都没有多态。 
    假设子类override父类的所有成员，包括静态成员、非静态属性和非静态方法。 
    由于构造子类时会先构造父类；而构造父类时，其所用的静态成员和非静态属性是父类的，但非静态方法却是子类的； 
    由于构造父类时，子类并未加载；如果此时所调用的非静态方法里有成员，则这个成员是子类的，且非静态属性是默认初始值的。
```