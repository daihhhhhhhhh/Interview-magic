# 使用synchronized修饰静态方法、非静态方法、对象、类有什么区别

**Synchronized修饰非静态方法**

Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。

Java中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由JVM 去分配下一个获得钥匙的人。

情况1：同一个对象在两个线程中分别访问该对象的两个同步方法

结果：会产生互斥。

解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。正如上面所解释的，相当于一个对象只有一把钥匙了，里面的两个同步方法是两个房间，因此，同一时间只能用一个钥匙访问一个方法。

情况2：不同对象在两个线程中调用同一个同步方法

结果：不会产生互斥。

解释：因为是两个对象，就相当于两个大房子，彼此之间互不干扰，具有两把钥匙。锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙。

**Synchronized修饰静态方法**

Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。

情况1：用类直接在两个线程中调用两个不同的同步方法

结果：会产生互斥。

解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。

注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。

情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法

结果：会产生互斥。

解释：因为是一个对象调用，同上。都调用静态方法的时候，相当于是同一个类锁，用的都是同一个类对象。

都调用非静态方法的时候，相当于是同一个对象锁。

情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法

结果：不会产生互斥。

解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。

**例子**

 

```
pulbic class Something(){

    public synchronized void isSyncA(){}
    
    public synchronized void isSyncB(){}
    
    public static synchronized void cSyncA(){}
    
    public static synchronized void cSyncB(){}

}
```



那么，加入有Something类的两个实例a与b，那么下列哪组方法可以被1个以上线程同时访问呢?



```
a. x.isSyncA()与 x.isSyncB()

b. x.isSyncA()与 y.isSyncA()

c. x.cSyncA()与 y.cSyncB()

d. x.isSyncA()与 Something.cSyncA()
```



这里，很清楚的可以判断：

a，都是对同一个实例的synchronized域访问，因此不能被同时访问

b，是针对不同实例的，因此可以同时被访问

c，因为是static synchronized，所以不同实例之间不会被限制

d，书上的答案是可以被同时访问的，答案理由是synchronzied的是实例方法与synchronzied的类方法由于锁定（lock）不同的原因。





引言java

synchronized，这个东西咱们通常称之为”同步锁“，他在修饰代码块的时候须要传入一个引用对象做为“锁”的对象。jvm

   在修饰方法的时候，默认是当前对象做为锁的对象
   在修饰类时，默认是当前类的Class对象做为所的对象
   故存在着方法锁、对象锁、类锁 这样的概念函数

那么咱们来大体看一下这三种锁spa

### **方法锁（synchronized修饰方法时）**

经过在方法声明中加入synchronized关键字来声明synchronized方法。
synchronized 方法锁控制对类成员变量的访问：
每一个类实例对应一把锁
每一个synchronized方法都必须得到调用该方法的类实例的”锁“方能执行，不然所属线程阻塞。.net

方法一旦执行，就会独占该锁，一直到从该方法返回时才将锁释放，此后被阻塞的线程方能得到该锁，从而从新进入可执行状态。线程

这种机制确保了同一时刻对于每个类的实例，其全部声明为synchronized的成员函数中之多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。3d

ok,下方介绍一个火车站卖票的例子，一共1000张票，有4个窗口卖票，卖票的方法被我定义为同步的，即每一个卖票过程会卖出4张票，卖完以后才容许其余窗口卖票对象

你们看看代码，体会一下blog

 

![方法锁代码.png](https://resource.shangmayuan.com/droxy-blog/2019/12/05/99727e83ce6a4bbea1a2440fb3c204b9-2.png)

运行结果内存

 

![运行结果.png](https://resource.shangmayuan.com/droxy-blog/2019/12/05/3de81ebe15814c7b941f6ce36112436e-2.png)

 

运行结果多运行几回会发现虽然线程的前后顺序会变化，可是每个线程一定先卖出4张票以后才会去接着卖剩余的票。

下边咱们来看下对象锁，其实方法锁 这个就属于对象锁

### **对象锁（synchronized修饰方法或代码块）**

当一个对象中有synchronized method 或synchronized block 的时候，调用此对象的同步方法或进入其同步区域时，就必须先得到对象锁。

若是此对象的对象锁已被其余调用者占用，则须要等待此锁被释放。（方法锁也是对象锁）

java的全部对象都含有一个互斥锁，这个锁由jvm自动获取和释放。

线程进入synchronized 方法的时候获取该对象的锁，固然若是已经有线程获取了这个对象的锁，那么当前线程会等待；

synchronized方法正常返回或者抛异常而终止，jvm会自动释放对象锁。这里也体现了用synchronized来加锁的一个好处，即 ：

### 方法抛异常的时候，锁仍然能够由jvm来自动释放

对象锁的两种方式
一、方法锁

 

![方法锁形式.png](https://resource.shangmayuan.com/droxy-blog/2019/12/05/396ea26dab584b75b38d74196823e0e7-2.png)

二、代码块形式

 

![代码块形式.png](https://resource.shangmayuan.com/droxy-blog/2019/12/05/fea5abc0a135423884d40ecd7da43681-2.png)

ok,本身体会一下哦

### 类锁（**synchronized修饰静态的方法或者代码块**）

因为一个class不论被实例化多少次，**其中的静态方法和静态变量在内存中都只有一份**。因此，一旦一个静态的方法被声明为synchronized。此类全部的实例对象在调用此方法，共用同一把锁，咱们称之为类锁。

 **前方高能：重点：要考的哦**

**对象锁是用来控制实例方法之间的同步，而类锁是用来控制静态方法（或者静态变量互斥体）之间的同步的。**

类锁只是一个概念上的东西，并非真实存在的，他只是用来帮助咱们理解锁定实例方法和静态方法的区别的。
java类可能会有不少对象，可是只有一个Class(字节码)对象，也就是说类的不一样实例之间共享该类的Class对象。**Class对象其实也仅仅是1个java对象，只不过有点特殊而已。**
因为每一个java对象都有1个互斥锁，而类的静态方法是须要Class对象。**因此所谓的类锁，只不过是Class对象的锁而已。**
**获取类的Class对象的方法有好几种，最简单的是[类名.class]的方式**。(百度：获取字节码的三种方式)

来看下类锁的两种方式
方式1：

 

![类锁1.png](https://resource.shangmayuan.com/droxy-blog/2019/12/05/353e5e818d7e490982118114aeaad149-2.png)

方式2：

 

![类锁2.png](https://resource.shangmayuan.com/droxy-blog/2019/12/05/00d8e6fbc77f4fefa061372805063b46-2.png)