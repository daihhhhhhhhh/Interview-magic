# 1.3.2sleep()、join()、yield()有什么区别

## 1、sleep()方法

sleep()方法需要制定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同等级或者高优先级的线程得到执行的机会，也可以让低优先级的线程的到执行的机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享的数据。

## 2、wait()

wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，他们都是Object类的方法，而不是Thread类的方法。

wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志“。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的所有权。当调用了某个对象的notifyAll()方法，会使对象等待池中的所有线程都异动到该对象的锁标志等待池。

除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程池将恢复到锁标志等待池。

此外，wait()，notify()，notifyAll()只能在synchronized语句中使用， 但是如果使用的是ReenTranLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTranLock.newCondition()获取一个Condition类对象，然后Condition的wait()，Signal()以及SignalAll()分别对应上面的三个方法。

## 3、yield()

yield()方法和sleep方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行的状态，所以执行yield()的线程有可能进入到可执行状态后又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。

## 4、join()

join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行。