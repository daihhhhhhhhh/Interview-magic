# 1、final

## 1.1修饰类

用final修饰的类，不能被其他类所继承。当需要让一个类永远不被继承，此时可以用final修饰，但是要注意：final类中所有的成员方法都会隐式的定义为final方法

## 1.2修饰方法

使用final方法的原因主要有2个：

（1）把方法锁定，防止继承类对其进行更改

（2）效率，在早期的java版本中，将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。

注意：若父类final方法的访问权限为private，将导致子类中不能直接继承该方法。因此，此时可以在子类中定义相同方法名的函数，此时不会重写final的矛盾，而是在子类中重新定义了新方法。

## 1.3修饰变量

 final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。 

- 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦初始化后便不能发生变化；

- 如果final修饰一个引用类型时，则在对其初始化后便不能让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。【本质上是final所指向的地址的值不发生变化】

final修饰一个成员变量（属性），必须要显示初始化。

- 变量声名的时候初始化

- 变量声名的时候不赋初值，但是要在这个变量所在的类的所有的构造方法中对这个变量赋初值

当函数的参数类型声名为final时，说明该参数是只读型的。即你可以使用该参数，但是无法改变该参数的值。

# 2、finally

只有与finally对应的try语句块得到执行的情况下，finally语句块才会执行。

在执行try语句块之前若已经返回或者抛出异常，finally语句块不会执行。

 在try-catch-finally语句中执行return语句。 

 ![](.\resource\1.1.2.png)

答案：4,4,4

首先finally语句在该代码中一定会执行，从运行结果来看，每次return的结果都是4，仿佛其他return语句被屏蔽掉了。

事实确实如此，因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。





 https://www.cnblogs.com/ktao/p/8586966.html 