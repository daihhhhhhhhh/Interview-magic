# 1、final

## 1.1修饰类

用final修饰的类，不能被其他类所继承。当需要让一个类永远不被继承，此时可以用final修饰，但是要注意：final类中所有的成员方法都会隐式的定义为final方法

## 1.2修饰方法

使用final方法的原因主要有2个：

（1）把方法锁定，防止继承类对其进行更改

（2）效率，在早期的java版本中，将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。

注意：若父类final方法的访问权限为private，将导致子类中不能直接继承该方法。因此，此时可以在子类中定义相同方法名的函数，此时不会重写final的矛盾，而是在子类中重新定义了新方法。

## 1.3修饰变量

 final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。 

- 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦初始化后便不能发生变化；

- 如果final修饰一个引用类型时，则在对其初始化后便不能让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。【本质上是final所指向的地址的值不发生变化】

final修饰一个成员变量（属性），必须要显示初始化。

- 变量声名的时候初始化

- 变量声名的时候不赋初值，但是要在这个变量所在的类的所有的构造方法中对这个变量赋初值

当函数的参数类型声名为final时，说明该参数是只读型的。即你可以使用该参数，但是无法改变该参数的值。

# 2、finally

只有与finally对应的try语句块得到执行的情况下，finally语句块才会执行。

在执行try语句块之前若已经返回或者抛出异常，finally语句块不会执行。

 在try-catch-finally语句中执行return语句。 

 ![](.\resource\1.1.2.png)

答案：4,4,4

首先finally语句在该代码中一定会执行，从运行结果来看，每次return的结果都是4，仿佛其他return语句被屏蔽掉了。

事实确实如此，因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。

# 3、finalize

finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回手的时候调用。其实gc可以回手大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员实现finalize的。

特殊情况下需要程序员实现finalize，当对象被回手的时候释放一些资源，比如：一个Socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。

使用finalize还需要注意一个事，调用super.finalize()；

一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立刻回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回手的时候，因为前面调用过一次，所以不会调用finalize()，产生问题，所以，推荐不要用finalize()方法，他跟析构函数不一样。





 https://www.cnblogs.com/ktao/p/8586966.html 