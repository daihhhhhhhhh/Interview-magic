# 一、内存溢出原因

内存溢出就是内存不够，引起内存溢出的原因有很多种，常见的有以下几种：

1、内存中加载的数据量过于庞大，如一次从数据库取出过多数据；

2、集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；

3、代码中存在死循环或循环产生过多重复的对象实体；

4、使用的第三方软件中的BUG；

5、启动参数内存值设定的过小；

 ![img](http://pics4.baidu.com/feed/bd315c6034a85edf533cef2ef38ce826dc54756d.jpeg?token=047d794650a9ae1b088ba51f4baab663&s=15904D30970E654B0669B4C20200C0B2) 

（1）程序计数器：程序计数器是线程私有的，主要的作用是通过改变这个计数器的值来选取下一条需要执行的字节码指令。既然每个线程都有一个，那么这些线程的计数器是互不影响的。也不会抛出任何异常。

（2）虚拟机栈和本地方法栈：虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。本地方法栈与虚拟机栈的区别是，虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机提供native方法服务。

在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。

（3）java堆和方法区：java堆区主要存放对象实例和数组等，方法区保存类信息、常量、静态变量等等。运行时常量池也是方法区的一部分。这两块区域是线程共享的区域，只会抛出OutOfMemoryError。

#  二、内存溢出实例 

## 1、堆溢出

既然堆是存放实例对象的，那我们就无线创建实例对象。这样堆区迟早会满。

 ![img](http://pics5.baidu.com/feed/500fd9f9d72a605906b8467292ecd59e023bba08.jpeg?token=67dbad3560ef23a785d6a3b71db1a88f&s=BA81E14C5AE08D6A18619803000030C1) 

##  2、虚拟机栈和本地方法栈溢出 

Java虚拟机规范中描述了两种异常：

如果线程请求的栈深度大于虚拟机锁允许的最大深度，将抛出StackOverflowError异常。

如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。第一种我们只需要使用方法递归调用即可模拟：

 第一种我们只需要使用方法递归调用即可模拟： 

 ![img](http://pics7.baidu.com/feed/8c1001e93901213ff95ada27ee3fd7d42e2e953a.jpeg?token=287a9d57e3c82bcb42e4d8befe83eb12&s=B281B14C1AAC956E4ECD750F0000E0C1) 

第二种也可以递归调用模拟,，但是使用的是类直接调用。

 ![img](http://pics6.baidu.com/feed/a8773912b31bb05171ad60878ca23bb148ede0f7.jpeg?token=b090bebb2767f0ec7807bab850a4f8e9&s=B281B14C1AA4836E0EC9F50F0000E0C1) 

##  3、方法区和运行时常量池溢出 

 ![img](http://pics6.baidu.com/feed/63d9f2d3572c11dfee52cc70d9ff83d5f503c2c4.jpeg?token=64ffc9065bafde79359331a2f6f213cf&s=3A81B14C92B5986F045C7C030000E081) 

##  4、本机直接内存溢出 

 DirectMemory容量可通过-XX: MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值 (-Xmx指定)一样。 

 ![img](http://pics3.baidu.com/feed/b7003af33a87e9509d5addfeaae0b246faf2b435.jpeg?token=770fec631d5e60439ce23adba5e4ea5a&s=3281B14C87F088605C69DC8300003081) 

# 三、内存溢出排查

排查其实最主要的就是检查代码，而且内存溢出往往都是代码的问题。当然一下几点都是需要注意的：

（1）内存中加载的数据量过于庞大，如一次从数据库取出过多数据；

（2）集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；

（3）代码中存在死循环或循环产生过多重复的对象实体；

（4）使用的第三方软件中的BUG；

（5）启动参数内存值设定的过小；

最后就是解决了。

第一步，修改JVM启动参数，直接增加内存。

第二步，检查错误日志

第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。

一般情况下代码出错的概率会比较大一些，当然了不同的场景不同错误总是复杂多样的。